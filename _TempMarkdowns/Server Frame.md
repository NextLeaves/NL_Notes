title: Server Frame
date: 2017-11-27 5:00:00
tag: unity3d

---

* 服务器架构

---

# 第七章 服务器架构 #

* 服务器端分为：底层框架和游戏逻辑框架
	* 底层框架：用于实现网络交互、数据存储

---
---

## 服务端架构 ##

### 总体架构 ###

* 服务端程序需要接受：客户端连接、处理游戏逻辑、存储玩家数据等功能
* 该三层架构框架，把服务端分为：
	1. 逻辑层
	2. 中间层
	3. 底层

### 游戏流程 ###

* 登录游戏 - 检验账号 - 数据库发送该用户数据 - 玩家进行操作 - 存储数据 - 退出游戏（退出前需要存储数据）
* 保存玩家数据的两种方式：
	* 定时存储数据，玩家进行游戏时，可能进行数据的存储
	* 玩家下线时，进行游戏的信息存储

### 连接的数据结构 ###

1. Conn：处理网络内容
2. Player：代表游戏中的角色内容
3. PlayerData：需要存储到数据库的信息
4. PlayerTempData：不需要保存的数据信息，比如：临时状态等

### 数据库结构 ###

1. 用户数据：玩家的账号和密码
2. 用户数据和游戏数据一般是分离开来的，因为可能要接入其他游戏平台，用以验证
3. 一般一个表能存储数百万的信息；若太多人数，可以通过分表分库的方式，进行缓解压力

### 项目结构 ###

* 逻辑层：
	1. HandlePlayerMsg：处理角色打斗信息
	2. HandleConnMsg：处理客户端连接处理
	3. HandlePlayerEvenet：处理用户事件：比如登录、登出等
* 中间层：
	1. Player：游戏中的角色；功能包括：给角色发送信息，下线提醒，保存角色数据
* 底层：
	1. ServerNet：网络底层；处理收到的客户端的信息内容
	2. DataMgr：数据库封装；读取数据信息，更新数据信息
* 其他：
	1. ProtocolBase：协议基类
	2. ProtocolBytes：基于字节流的协议
	3. ProtocolStr：基于字符串的协议
	4. Sys：存放辅助方法，比如：时间戳的获取等

---
---

## 数据管理类（DataMgr） ##

* DataMgr：用于处理数据库等一系列的操作方式
	1. 用户数据的判定，检验
	2. 或者用户数据的注册
	3. sql注入检测
	4. 获取玩家数据
	5. 保存角色数据

### 数据表结构 ###

* 网路游戏包含：用户数据和角色数据
* game库：
	* user表：账号、密码
	* player表：id、序列化角色data

### 角色数据 ###

* 假设palyerdata只需要score需要存储
* 添加Attribute：[Serializable]

### Player的初步版本 ###

* player指代玩家；游戏中的角色为id和playerdata
* 包含：游戏id、游戏数据playerdata、链接conn

### 链接数据库 ###

* 实现单例模式
* sqlconnection类，存储链接到数据的对象

### 防止sql注入 ###

* sql语句：string sql = "sql * from player where id="+id;
* 如果非法人员执行：xiaoming;delete * from player;
* 很危险的事情，导致删除所有的player信息
* 使用正则表达式，判断输入的信息是否正确，是否合法

### Register注册 ###

* 判断是否非法字符（使用RegEx类）
* 判断是否存在账号（使用数据库语句）
	* 若未注册，进行快捷注册方式
	* 若注册，进行校验，登录游戏

### 创建对象 ###

* 创建对象数据，并序列化为memorystream
* 转换为字节数组，便于处理数据库存储
* 数据库语句保存字节数组
	* 运用data=@data;语句
	* 为command的成员parameters.Add("@data",具体的参数类型:MysqlDbType.Bolb)
	* 设置参数值:command.parameter[0].Value=转换为的字节流数组

### 登录校验 ###

* 获取用户的输入，判断是否存在账号且密码正确

### 获取角色数据 ###

* 根据角色的id，找到对象的二进制palyerdata数据
* DataReader.GetBytes(int i,long dataIndex,byte[] buffer,int bufferIndex,int length)
	* int i：代表每一条数据的列数据；简单来说就是存储信息的排序顺序
	* dataIndex：其实读取位置
	* buffer：需要存储的缓存
	* bufferIndex：从buffer的什么位置开始存储
	* length：需要读取多长
	* 返回值：实际读取的长度

### 保存角色数据 ###

* 序列化角色数据
* 使用数据库语句，执行数据存储

### 调试 ###

* 注册角色
* 修改分数值
* 登录角色

---
---

## 网络管理类（ServerNet） ##

### Conn（客户端连接处理类） ###

* 粘包分包现象
* 粘包分包的处理方式；使用整型来标记每次所传达的信息长度
* Conn的设计处理，保存客户端的一个连接服务

### 网络处理类（ServerNet类） ###

* 实现服务器的基本操作，bind、listen、beginAccept
* ReceiveCb处理粘包分包机制
	* Array.Copy()：进行数组的拷贝或者可以进行覆盖

### 发送消息 ###

* 组合消息，长度+具体消息内容；发送！

### 启动服务器 ###

* 开启服务器操作，在主函数中

### 调试 ###

* 在unity客户端中相应的修改
* Receive内容
* Send内容

### 心跳（心跳机制） ###

* 当客户端死机、或者网线被拔出的时候，服务器与客户端无法进行四次挥手的操作，造成服务器滞留很多“死”的客户端留存，导致其他客户端可能无法连接
* 在每个客户端下保存一个lastticktime，来标致是否留存的方式
* 编写一个GetTimeStamp()：用于获取当前的时间戳（1970-1-1-8-0-0开始的），也称为格林威治时间
* 使用Timer进行，重复的判断

### 心跳协议 ###

* 负责在服务器端更新客户端发送的心跳信息，用于更新服务器的心跳值
* 在ReceiveCb中进行处理

### 调试心跳协议 ###

* 在客户端进行，更新服务器端的心跳内容，测试

---
---

## 协议 ##

* 开发一套通用服务器框架，只需要定义好解码和编码的方式
	1. 底层实现两层协议：处理消息长度、处理具体消息

### 协议基类 ###

* 解码（Decode）
* 编码（Encode）
* 获取协议名称（GetProtocolName）
* 打印输出的描述（GetExpression）
* 实现最简单的：字节流协议和字符串协议

### 字符串协议 ###

* （解码）实现把**二进制数据**转换为**字符串数据**
* （编码）实现把**字符数据**转换为**二进制数组数据**
* （获取协议名）从接受的消息中，获取相应位置，表示协议名的位置
* （描述）输出获取的协议内容，用于直接展示协议的内容

### 字节流协议 ###

* **前提：**约定字节流协议开头必须是字符串
* （解码）实现把获取的字节流，复制到协议字段bytes中
* （编码）直接返回协议中的bytes
* （获取协议名）获取获取的字节流中存在的约定的字符串，并发送字符串
* （描述）以字符串的形式输出协议内容（即实际传输的信息）


### 字节流辅助方法 ### 

* **声明提醒**：每次所传输的协议，依次的顺序为：总内容长度+协议名称+x、y、z二进制值
* **添加字符串方法（AddString()方法）**
	* 如果获取消息后，协议中的bytes中有消息，则使用bytes，进行concat操作
	* 如果协议中的bytes为空，则直接使用临时的消息作为整体，使用concat操作
* **获取字符串信息(GetString(int start,int end=0)方法)**
	* 若为空，则返回
	* 若消息长度小于4，则出错
	* 获取消息长度，用于复制协议获取的bytes中，相对应的消息内容
	* BitConverter.ToInt32(byte[] bytes,int startIndex)：从bytes数组中，提取从startIndex开始的后sizeof(int32)个数据，转换为32位的整型
	* end参数用于记录此次获取字符串后的位置，用于在下次使用开始的位置记录
* BitConverter.GetBytes()用于把对应的类型转换为byte类型存储，比如：int32存储为byte的话，就是占用4个字节
* 整型的获取方式：
	* 把消息长度，转换为byte数组存储的方法：
		* 调用BitConverter.GetBytes()
		* 若为空，则失败
		* 若正确，则进行concat操作
	* 获取消息长度，转换为整型类型的方法：
		* byte为空，返回
		* byte的长度小于start+sizeof(int32)
		* 执行操作，调用BitConverter.ToInt32()，获取bit数组中start开始的后4位值
* 浮点型的获取方式：
	* 把消息长度，转换为byte数组存储的方法：
		* 调用BitConverter.GetBytes()
		* 若为空，则失败
		* 若正确，则进行concat操作
	* 获取消息长度，转换为整型类型的方法：
		* byte为空，返回
		* byte的长度小于start+sizeof(int32)
		* 执行操作，调用BitConverter.ToSingle()，获取bit数组中start开始的后4位值

### 使用协议 ###

* 在ReceiveCb中处理获取的消息，利用协议来处理获取的信息

### 调试 ###

* 在客户端中配合，实现协议的内容，遵守相应的数据格式，以及顺序


---
---

## 中间层（Player） ##

* Player代表游戏中的角色；处理角色登录、登出、保存角色数据、向角色发送信息

### 登录流程 ###

* 若未登录状态；则进行数据校验、读取数据、向角色发送消息

### 下线 ###

* KickOff()：实现踢账号的操作
* Logout()：实现账号退出操作；角色数据的保存，socket退出

### Player类的实现 ###

* id：标志角色的信息
* conn：用于链接服务器
* data：用户数据，用于数据库存储的
* datatemp：临时数据
* KickOff()
* Logout()

### 消息分发 ###

* 