title: Diagnostic In VS
date: 2017-10-24 8:18:00
tag: CSharp

---

* This program is often used in VS.
* IDE中的调试方法
* C#中错误的处理技术

<!--more-->

# VS中的调试技术 #

* 一些错误为简单错误；一些错误为**致命错误**
	* 语法错误
	* 运行期间发生的更严重错误
	* 语义错误、逻辑错误

## 7.1 VS中的调试 ##

* 默认为**调试模式(F5)**
* 调试模式下会生成**.pdb（program debug database）**后缀的文件，存储应用程序的**符号信息**，用于了解每行代码所执行的内容


## 7.2 非中断（正常）模式下的调试 ##

*  输出信息的方法
	*  Output窗口中：
		*  Debug模式：运行期间的信息，即**Debug类**和**Trace类**输出的信息
		*  Build模式：编译信息
	*  可以把运行期间的信息，写到日志中
* **方法一：输出调试信息**
	1. Debug.WriteLine()
	2. Trace.WriteLine()
	3. 区别在于：
		* Debug只能在调试模式下运行，在发布版本中，甚至不能编译到发布本部，编译的代码更小
		* Trace都可以输出
	4. 都包含在**Using System.Diagnostics;**，且**using static只能引用静态类**
* **方法二：跟踪点**
	* 不修改代码的同时，实现输出信息的效果
	* 跟踪点是断电的一种形式（可以暂停应用程序的执行）
* 前面两者的区别：
	1. 跟踪点无法保存在应用程序中，不跟随应用程序；只有在VS中才起作用
	2. 跟踪点的一个缺点又是优点，便于调试输出程序的信息，不必删除，禁用就好
	3. 跟踪点的优点，可以输出函数名
* 使用技巧：
	* **诊断输出**适用于复杂的信息输出，并且需要进行记录的
	* **跟踪点**适用于快速查找语句错误等忽视的细节问题

## 7.3 中断模式下的调试 ##

* **方法一：断点**只能适用于调试模式下的编程；对于**发布版的程序直接忽略所有断电**
* 快捷键：F9
* **方法二：**
	* Debug.Assert()
	* Trace.Assert()
	* Debug适用于前期的中断调试
	* Trace适用于在发布版本之前的批量测试内容，用于让用户发现错误，反馈程序员

## 7.4 中断的时候能做什么 ##

* **监视变量的值**
	* 在调试的时候，左下角窗口的变化
	* **自动窗口：**当前和前面语句使用的变量
	* **局部变量：**作用域内的所有变量
	* **监视：**可定制的变量和表达式显示（Debug|Windows|Watch），在Watch中键入作用域内需要监视的标量值即可
* **单步执行代码**
	* **Step Into:**每条语句执行
	* **Step Over:**逐过程，跳过函数和代码块
	* **Step Out:**执行代码块末尾处，重新中断，跳出
* **Immediate & Command 窗口**
	* 输入cmd，切换**Command窗口**
	* 输入immed，切换**Immediate窗口**
	* Immediate用于计算值，等简单的利用中断处变量
	* Command用于复杂的操作，（未介绍）
* **Call Stack 窗口**
	* 记录此语句调用的父位置，调用的函数位置，调用函数的函数等

## 7.5 错误处理 ##

*  **错误原因：**
	*  由于程序在运行时产生的错误，又或是在调用函数的时候，出现的错误；如：调用函数的字符串输入错误、数组的下标溢出
*  **try..catch..finall**
	* 结构化异常处理(SEH Structured Exception Handling)
	* 如果没有**catch块**必须有**final块**；若有**catch块**则**final块**是可选
* C#6.0新语法，**“异常过滤”**
	* catch块捕获后，when为true则执行
* 若有两个或者以上的catch块相同，when后为true的执行，若再相同，则只执行一个catch块的内容
* 打开行号：TextEditor|C#|General
* **列出和配置异常：**
	* 可以检查和编辑可用的异常类
	* 已处理的和未处理的异常，都会放置在里面
* **checked**和**Unchecked**关键词的用法：
	* 检查或者不检查**数学运算的溢出**
	* 编译器能检查出来的溢出，仅限于常量的溢出
	* 对于变量的操作，若不操作checked关键词修饰，则能够计算出值，但是无法获取正确的值
	* 针对于多个位置可能溢出的操作，则使用**checked块**操作
	* **checked在避免算术溢出方面很有用，那么unchecked呢，它有用吗？**答案是肯定的，有时候我们不需要准确的计算结果，我们只是需要那么一个数而已，至于溢出不溢出的关系不大，比如说生成一个对象的HashCode，比如说根据一个算法计算出一个相对随机数，这都是不需要准确结果的。
	* **checked和unchecked是可以嵌套使用的**，虽然没啥意义。语句是否是checked以最近嵌套的checked或者unchecked决定