title: 托管和非托管资源
date: 2017-12-4 13:30:00
tag: CSharp High

---

* 运行期间在**栈**和**堆**上分配空间
* 垃圾回收
* 使用析构函数和实现**IDispose**接口来释放非托管资源
* C#中使用指针的语法
* 使用指针实现基于栈的高性能数组
* 平台调用，访问本机API

<!--more-->

# 第五章 托管和非托管资源 #

## 1.资源 ##

* 资源：是一个被反复使用的术语
* 托管和非托管的资源---存储在托管或本机堆中的对象
	* 垃圾收集器（GC）只能释放存储在托管堆中的对象，但是无法释放本机堆中的资源，必须由开发人员进行释放
* 了解内容：
	1. GC如果工作？
	2. 什么数据类型存储在堆栈的什么位置，以及方式
	3. 什么是**大小对象堆**
	4. 以及框架中存在的本地的方式，比如文件包装了一个本地文件的句柄，需要程序员自己进行释放

## 2. 后台内存管理 ##

* C#的其中一个优点是程序员不需要关心任何编写的托管代码部分，因为其中存在CLR的GC机制来处理和释放所有托管中的代码；已至于简化C#的后续处理事情，像C++一样更高的效率来处理应用程序
* 但是程序员也应该理解，分配内容时，在内存分配的一些机制和方式

### 2.1 值数据类型 ###

* windos使用的虚拟寻址系统
* 32位处理器在处理32位应用程序时，只能利用4Gb的内存空间
	* 其中内存存储空间包括：
		1. 可执行代码
		2. 代码加载的所有DLL
		3. 以及程序在实际上包含了所有的变量
	* 这个空间被称为虚拟空间和虚拟地址或者虚拟内存
* 在编译器中，Debug模式下，可以使用x86和x64不同模式下调试
* 虚拟内存单元，都是从0开始往上开始排序的
* 虚拟内存中有一个区域叫做**stack**，存储不是对象成员的值类型
* 对于作用域的相关问题：
	* 先分配的变量，和后分配的变量，其后者的作用域更短
	* 栈释放变量的时候，总是和分配变量的顺序相反，这就是栈的工作方式
	* 什么是**块作用域**和**结构作用域**？
* 栈的存储方式：栈从上往下进行存储，即从高内存地址到低内存地址的过程存储
* 如果像是i，j这种同时分配的栈类型的数据；对于程序员来说，谁先进行分配的已经不重要了，因为运行时会保证先分配的空间会后被释放，也就保证了正常的生存周期

### 2.2 引用数据类型 ###

* 栈具有高性能的优势，但是在存储多数据的情况下，且很长时间后还能继续使用的话，就要使用new创建的类型，来在heap中生成对象
* heap的分配方式，从下往上进行分配的，所以空闲堆在空间的上方
* 可以在栈中使用两个引用变量，这样栈中存在两个引用变量指向栈中的数据实例；只要有变量实例有引用栈，则具体的数据不会消失，至于没有引用变量之后，接下来就有GC来处理变量实例的垃圾回收机制

### 2.3 垃圾回收 ###

* 因为堆中的数据存储的方式不像栈一样，连续的；可能在后面才会删除中间存在未引用的变量实例，所以在GC运行的时候，会释放不再引用的变量实例，然后再把堆中存储的数据实例，依次的向上排列，这样保证下一次分配大数据空间的时候，不需要再次寻找合适的存储空间，保证推中空间的连续使用
	* 当然保证栈中引用的修改后的数据存储空间
* 强制某个地方调用垃圾回收机制：System.GC.Collect():
	* 在大量消失对象引用的时候，可以强制调用
	* 但是仍不能保证所有的未引用的实例被释放
	* 让GC中待释放的对象，更快的移动到下一代
* 堆的分布问题：
	* **新分配的对象**被称为第0代；直到第一次调用垃圾回收机制时候
	* 第一次调用GC后遗留下来的对象：被称为第1代，依次根据GC的调用来分布堆中的对象分布
* 如果超出第0代，或者调用GC的时候，就会进行对象的释放
* 保证了释放对象的高效率，一般保存的越久的对象，越不容易释放，保证了越容易释放的对象，排序在相同的位置，更利于垃圾的回收
* 另一个提高性能，处理堆上的大对象时：利用**架构处理堆**
	* 大对象存在自己的大对象托管堆
	* 大于85000个字节的对象，存储在**非主堆**上，而是**大对象堆**上
	* 在大对象上执行压缩是比较昂贵的，所以大对象一般不执行压缩操作
	* 默认在第0代和第1代执行回收和阻塞操作，这样减少总的阻塞时间
* 另一个提高性能，垃圾回收平衡机制：
	* 专用于服务器的垃圾回收
	* 在虚拟服务器上存在线程池的逻辑，如果单个线程的所利用的空间用完，导致触发垃圾回收机制，这样会同时引起其他线程的垃圾回收机制，这样可能其他线程不需要垃圾回收，这样导致性能很低
	* 平衡上述过程，按权分配内存，保证内存的相互的足够使用
* 为了利用包含大量内存硬件，垃圾回收机制添加了**GCSettings.LatencyMode**枚举，控制垃圾回收的方式

## 3. 强引用和弱引用 ##

* 只要有一个变量引用类型，则该引用为强引用
* **提醒：**使用事件很容易错过引用的清理，此时可以使用弱引用
* 弱引用：允许创建和使用对象，但碰巧GC运行，则就会回收对象，并释放内存；由于存在潜在的bug和和性能问题，一般不会这么做
	* 弱引用不适合用于小对象，因为弱引用也存在性能消耗，可能比小对象更消耗性能
	* WeakReference类，传递一个强引用到该类的构造函数，实现创建一个弱引用
		* Target属性可以返回一个强引用
		* IsAlive属性，判断是否还存在实例数据

## 4. 处理非托管的资源 ##

* 	